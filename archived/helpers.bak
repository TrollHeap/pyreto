#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import os
import re
import json
import textwrap
import tempfile
import subprocess
from datetime import datetime, timedelta
from pathlib import Path
from typing import Optional, Iterable

# =========================
# Shell & File primitives
# =========================

def run_cmd(cmd: list[str], *, cwd: Path | None = None) -> str:
    """Exécute une commande et retourne stdout. Lève une erreur avec stderr en contexte."""
    try:
        res = subprocess.run(
            cmd, cwd=str(cwd) if cwd else None,
            capture_output=True, text=True, check=True
        )
        return res.stdout
    except subprocess.CalledProcessError as e:
        raise RuntimeError(
            f"Command failed: {' '.join(cmd)}\nSTDERR:\n{e.stderr}"
        ) from e


def _atomic_write(path: Path, content: str) -> None:
    """Écriture atomique : écrit dans un tmp puis remplace (évite les fichiers corrompus)."""
    path.parent.mkdir(parents=True, exist_ok=True)
    with tempfile.NamedTemporaryFile("w", encoding="utf-8", dir=path.parent, delete=False) as tf:
        tf.write(content)
        tmp_name = tf.name
    os.replace(tmp_name, path)


def write_text(path: Path, content: str) -> None:
    _atomic_write(path, content)


def read_text(path: Path) -> str:
    return path.read_text(encoding="utf-8")


# =========================
# Paths & Structure
# =========================

def safe_slug(s: str) -> str:
    return "".join(ch if ch.isalnum() or ch in ("-", "_") else "-" for ch in s.strip().lower()).strip("-")


def ensure_dirs(base: Path, topic_slug: str) -> dict[str, Path]:
    cheats_dir = base / "cheatsheets" / topic_slug
    ex_dir = base / "exercises" / topic_slug
    meta_dir = base / topic_slug
    for d in (cheats_dir, ex_dir, meta_dir):
        d.mkdir(parents=True, exist_ok=True)
    return {"cheats": cheats_dir, "ex": ex_dir, "meta": meta_dir}


def list_exercise_files(ex_dir: Path) -> list[Path]:
    """Exercices triés (date+nom), déterministe."""
    return sorted(ex_dir.glob("*.txt"))


def get_editor() -> str:
    return os.environ.get("VISUAL") or os.environ.get("EDITOR") or "vi"


def open_in_editor(path: Path) -> None:
    subprocess.run([get_editor(), str(path)])


# =========================
# Exercises: parsing & IO
# =========================

_EX_SPLIT = re.compile(r"\n(?=(EX\d{2}\b))")  # garde le marqueur en tête de bloc
_EX_ID = re.compile(r"^EX(\d{2})\b")

def _split_exercise_chunks(content: str) -> list[str]:
    """Découpe un texte multi-exos en blocs EX01..EXNN. Robuste aux espaces en tête/fin."""
    if not content:
        return []
    parts = _EX_SPLIT.split("\n" + content.strip())
    # parts = ["", "EX01...", "EX02...", ...] ; filtrer vides et joindre ID avec contenu
    chunks = []
    i = 1
    while i < len(parts):
        ident = parts[i].strip()
        body = parts[i + 1].strip() if i + 1 < len(parts) else ""
        chunks.append((ident, body))
        i += 2
    # Recompose "EX01\n<contenu>"
    return [f"{ident}\n{body}".rstrip() for ident, body in chunks if ident]


def create_exercise_files(ex_dir: Path, date_str: str, n: int, content: str | None) -> list[Path]:
    """Crée n fichiers d'exercices, en remplissant avec le contenu généré si présent."""
    paths: list[Path] = []
    generated: list[str] = _split_exercise_chunks(content) if content else []

    for i in range(1, n + 1):
        ident = f"ex{i:02d}"
        fname = f"{date_str}-{ident}.txt"
        p = ex_dir / fname
        if i <= len(generated):
            write_text(p, generated[i - 1] + "\n")
        else:
            skeleton = textwrap.dedent(f"""\
            EX{i:02d} — Sujet: (remplis-moi)
            --------------------------------
            Objectif (1 phrase) :
              - …

            ÉNONCÉ (3–6 lignes) :
              - …

            ENTRÉE (exemple) :
            ```text
            …
            ```

            LIVRABLES :
              - …

            CRITÈRES D'ACCEPTATION :
              - …
              - …

            CONTRAINTES :
              - Sans script externe / sans internet (sauf spécifié)
              - Timebox : 10–15 min
            """).rstrip() + "\n"
            write_text(p, skeleton)
        paths.append(p)
    return paths


def create_launcher_script(ex_dir: Path, topic_slug: str) -> Path:
    """Lanceur plus ergonomique : fzf si présent, sinon dernier modifié, sinon plus ancien."""
    sh = ex_dir / f"run_{topic_slug}.sh"
    editor = get_editor()
    content = textwrap.dedent(f"""\
    #!/usr/bin/env bash
    set -euo pipefail
    cd "$(dirname "$0")"

    shopt -s nullglob
    files=(*.txt)
    if [[ ${{#files[@]}} -eq 0 ]]; then
      echo "[ERR] Aucun exercice .txt dans $(pwd)" >&2
      exit 1
    fi

    pick=""
    if command -v fzf >/dev/null 2>&1; then
      pick="$(printf '%s\n' "${{files[@]}}" | fzf --prompt='Exercice > ' --height=40% --reverse || true)"
    fi

    if [[ -z "$pick" ]]; then
      # si pas fzf: ouvrir le plus récent modifié, sinon le plus ancien si tie
      pick="$(ls -1t *.txt | head -n1 || true)"
      if [[ -z "$pick" ]]; then
        pick="$(ls -1 *.txt | head -n1)"
      fi
    fi

    echo "[INFO] Ouverture: $pick"
    {editor} "$pick"
    """).strip() + "\n"
    write_text(sh, content)
    sh.chmod(0o755)
    return sh


# =========================
# Manifest & Progress
# =========================

def _topic_manifest_path(base: Path, topic_slug: str) -> Path:
    return (base / topic_slug / "manifest.json")


def write_manifest(base: Path, topic: str, topic_slug: str, cheats_dir: Path, ex_files: list[Path]) -> Path:
    """Indexe le sujet : cheatsheet + exercices + métadonnées. Merge non-destructif."""
    manifest_path = _topic_manifest_path(base, topic_slug)
    record = {
        "schema": 1,
        "topic": topic,
        "topic_slug": topic_slug,
        "created_at": datetime.now().isoformat(timespec="seconds"),
        "cheatsheet": str((base / "cheatsheets" / topic_slug / f"{topic_slug}.md").expanduser()),
        "exercises": [str(p.expanduser()) for p in sorted(ex_files)],
        "attempts_log": str((base / topic_slug / "attempts.jsonl").expanduser()),
        "last_updated": datetime.now().isoformat(timespec="seconds"),
    }
    existing = {}
    if manifest_path.exists():
        try:
            existing = json.loads(read_text(manifest_path))
        except Exception:
            existing = {}
    existing.update(record)  # override champs récents
    write_text(manifest_path, json.dumps(existing, indent=2, ensure_ascii=False) + "\n")
    return manifest_path


def _attempts_log_path(base: Path, topic_slug: str) -> Path:
    return base / topic_slug / "attempts.jsonl"


def record_attempt(
    base: Path,
    topic_slug: str,
    exercise_file: Path,
    status: str,                     # "pass" | "fail" | "skip"
    duration_sec: Optional[int] = None,
    notes: Optional[str] = None,
) -> Path:
    """Append-Only journal (JSONL) des tentatives : une ligne par essai."""
    entry = {
        "ts": datetime.now().isoformat(timespec="seconds"),
        "exercise": str(exercise_file),
        "status": status,
        "duration_sec": duration_sec,
        "notes": notes,
    }
    log = _attempts_log_path(base, topic_slug)
    log.parent.mkdir(parents=True, exist_ok=True)
    with log.open("a", encoding="utf-8") as f:
        f.write(json.dumps(entry, ensure_ascii=False) + "\n")
    # update manifest last_updated
    mpath = _topic_manifest_path(base, topic_slug)
    if mpath.exists():
        try:
            man = json.loads(read_text(mpath))
            man["last_updated"] = datetime.now().isoformat(timespec="seconds")
            write_text(mpath, json.dumps(man, indent=2, ensure_ascii=False) + "\n")
        except Exception:
            pass
    return log


def read_attempts(base: Path, topic_slug: str) -> list[dict]:
    log = _attempts_log_path(base, topic_slug)
    if not log.exists():
        return []
    rows = []
    with log.open("r", encoding="utf-8") as f:
        for line in f:
            line = line.strip()
            if not line:
                continue
            try:
                rows.append(json.loads(line))
            except Exception:
                continue
    return rows


# =========================
# Practice helpers
# =========================

def _done_files_from_attempts(attempts: list[dict]) -> set[str]:
    """Considère un exercice 'done' s'il a au moins un pass ; 'seen' s'il a au moins une tentative."""
    done = set()
    for a in attempts:
        if a.get("status") == "pass":
            done.add(a.get("exercise", ""))
    return done


def pick_next_exercise(ex_dir: Path, base: Path, topic_slug: str, strategy: str = "oldest-unattempted") -> Optional[Path]:
    """
    Heuristique simple :
    - 'oldest-unattempted' : plus ancien fichier jamais 'passé'
    - fallback : plus ancien tout court
    """
    files = list_exercise_files(ex_dir)
    if not files:
        return None
    attempts = read_attempts(base, topic_slug)
    done = _done_files_from_attempts(attempts)

    if strategy == "oldest-unattempted":
        for f in sorted(files, key=lambda p: (p.stat().st_mtime, p.name)):
            if str(f) not in done:
                return f
    # fallback
    return sorted(files, key=lambda p: (p.stat().st_mtime, p.name))[0]


def suggest_review_dates(status: str, start: datetime | None = None) -> list[str]:
    """
    SRS light (dates ISO) :
    - pass : +1d, +3d, +7d
    - fail : +0d (revoir aujourd'hui), +1d, +2d
    - skip : +1d, +2d
    """
    now = start or datetime.now()
    if status == "pass":
        offs = [1, 3, 7]
    elif status == "fail":
        offs = [0, 1, 2]
    else:  # skip
        offs = [1, 2]
    return [(now + timedelta(days=d)).date().isoformat() for d in offs]


def write_review_schedule(base: Path, topic_slug: str, exercise_file: Path, status: str) -> Path:
    """Écrit/merge un plan de révision minimal par exo."""
    plan_path = base / topic_slug / "reviews.json"
    plan = {}
    if plan_path.exists():
        try:
            plan = json.loads(read_text(plan_path))
        except Exception:
            plan = {}
    key = str(exercise_file)
    plan[key] = {
        "last_status": status,
        "next_dates": suggest_review_dates(status),
        "updated_at": datetime.now().isoformat(timespec="seconds"),
    }
    write_text(plan_path, json.dumps(plan, indent=2, ensure_ascii=False) + "\n")
    return plan_path
